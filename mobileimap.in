#! /usr/bin/env ruby
#
# mobileimap - an IMAP-based web mailer for mobile phones.
#
# Copyright (C) 2003-2004 Satoru Takabayashi <satoru@namazu.org> 
#     All rights reserved.
#     This is free software with ABSOLUTELY NO WARRANTY.
#
# You can redistribute it and/or modify it under the terms of 
# the GNU General Public License version 2.
#
#

$KCODE = "e"
require 'net/imap'
require 'net/smtp'
require 'kconv'
require 'getoptlong'
require 'thread'
require 'thwait'
require 'timeout'
require 'time'
require 'socket'
require 'uri'
require 'cgi'

module Net
  class IMAP
    def self.new2 (host, port, use_ssl)
      if RUBY_VERSION > '1.8'
        Net::IMAP.new(host, port, use_ssl)
      else
        Net::IMAP.new(host, port)
      end
    end

    def authenticate2 (auth, user, password)
      if auth.upcase == "PLAIN"
        self.login(user, password)
      else
        self.authenticate(auth, user, password)
      end
    end
  end
end

module MobileImap
  VERSION = @VERSION@
  module_function
  begin
    raise unless Net::IMAP::respond_to?(:decode_utf7)
    require 'iconv'
    def decode_imap_utf7 (str)
      begin
        c = Iconv.new("euc-jp", "utf-8")
        str = Net::IMAP::decode_utf7(str)
        c.iconv(str)
      rescue
        str
      end
    end

    def encode_imap_utf7 (str)
      begin
        c = Iconv.new("utf-8", "euc-jp")
        str = c.iconv(str)
        Net::IMAP::encode_utf7(str)
      rescue
        str
      end
    end
  rescue Exception
    def decode_imap_utf7 (str)
      str
    end

    def encode_imap_utf7 (str)
      str
    end
  end
end

class String
  def safe_toeuc
    if (m = /=\?(.*?)\?/.match(self) and
        /^(ISO-2022-JP|Shift_JIS|EUC-JP)$/i.match(m[1])) or 
        /\e\$B/.match(self)
      self.toeuc
    elsif (m = /=\?(.*?)\?/.match(self) and
           /^(ISO-8859-1)$/i.match(m[1]))
      self.toeuc.gsub(/[^\s\x20-\x7e]/n, "?")
    else
      self.gsub(/[^\s\x20-\x7e]/n, "?")
    end
  end

  def safe_tosjis
    # not to do mime decoding.
    NKF.nkf('-Esm0', self)
  end

  def cut (len)
    self[0, len].scan(/.+/m).first
  end

  def xchomp
    self.sub(/[\r\n]+\z/, "")
  end

  def escapeURL
    CGI.escape(self)
  end

  def unescapeURL
    CGI.unescape(self)
  end

  def escapeHTML
    CGI.escapeHTML(self)
  end

  def untabify
    tmp = self.clone
    true while tmp.gsub!(/\t+/) { 
      ' ' * ($&.length * 8 - $`.length % 8) }
    tmp
  end
end

module Zlib
  def required_version? (required_version)
    begin
      a = Zlib::VERSION.split(".").map {|x| x.to_i }
      b = required_version.split(".").map {|x| x.to_i }
      (a.length).times {|i|
        if a[i] > b[i]
          return true
        elsif a[i] < b[i]
          return false
        end
      }
      return true
    rescue
      return false
    end
  end
  module_function :required_version?
end

class HttpWriter
  CRLF = "\r\n"
  def initialize (out, logger)
    @out = out
    @logger = logger
    @encoding = nil
    @zlib_loaded_p = false
    begin 
      require 'zlib'
      zlib_version = "0.6.0"
      if Zlib::required_version?(zlib_version)
        @zlib_loaded_p = true
      else
        logger.log("Ruby/Zlib #{zlib_version} or later is required")  
      end
    rescue LoadError
    end
  end
  attr_reader :encoding

  def enable_gzip
    @encoding = "gzip" if @zlib_loaded_p
  end

  def enable_x_gzip
    @encoding = "x-gzip" if @zlib_loaded_p
  end

  def print (body, 
             content_type = "text/html; charset=Shift_JIS",
             additional_header = {})
    body = "" if body.nil?
    encoding = @encoding if @encoding and /^text/.match(content_type)
    @out.write("HTTP/1.0 200 OK" + CRLF)
    @out.write("Content-Type: #{content_type}" + CRLF)
    @out.write("Content-Encoding: #{encoding}" + CRLF) if encoding
    @out.write("Last-Modified: #{Time.now.httpdate}" + CRLF)
    @out.write("Expires: #{(Time.now + 600).httpdate}" + CRLF) # 10 minutes
    @out.write("Connection: close" + CRLF)
    additional_header.each {|key, value|
      @out.write("#{key}: #{value}" + CRLF)
    }
    @out.write(CRLF)

    out = if encoding then Zlib::GzipWriter.new(@out) else @out end
    if /^text/.match(content_type)
      body.each_line {|line| out.write(line.xchomp.safe_tosjis + CRLF) }
    else
      out.write(body)
    end
    out.finish if out.respond_to?(:finish)
  end
end

class Exception
  def to_html
    g = SimpleHtmlGenerator.new
    g.p {
      ([self.message] + self.backtrace).map {|line|
        line.escapeHTML + g.br
      }.join('')
    }
  end

  def to_html_simple
    g = SimpleHtmlGenerator.new
    g.p { self.message.escapeHTML }
  end
end

class TCPSocket
  def peer_address
    peeraddr[3]
  end

  def peer_hostname
    peeraddr[2]
  end
end

module OpenSSL
  module SSL
    class SSLSocket
      def peer_address
	io.peer_address
      end
      def peer_hostname
	io.peer_hostname
      end
    end
  end

  module_function

  # Imported from ossl-0.2.0-pre0/examples/ssl/example.rb
  # and modified a little.
  def get_key_and_cert (key_path = nil, cert_path = nil)
    if key_path && cert_path
      rsa = PKey::RSA.new(File.open(key_path).read)
      cert = X509::Certificate.new(File.open(cert_path).read)
    else
      # we are going to create a self-signed certificate.
      rsa = PKey::RSA.new(512) # be quiet for mobileimap

      cert = X509::Certificate.new
      cert.version = 2
      cert.serial = 0
      name = X509::Name.new([["CN","Test"],["O","OSSL"],["C","JP"]])
      cert.subject = name
      cert.issuer = name
      cert.not_before = Time.now
      cert.not_after = Time.now + (365*24*60*60)
      cert.public_key = rsa.public_key
      ef = X509::ExtensionFactory.new(nil,cert)
      cert.extensions = [
        ef.create_extension("basicConstraints","CA:FALSE"),
        ef.create_extension("subjectKeyIdentifier", "hash")
      ]
      ef.issuer_certificate = cert
      cert.add_extension ef.create_extension("authorityKeyIdentifier",
                                             "keyid:always,issuer:always")
      cert.add_extension ef.create_extension("nsComment",
                                             "Generated by OpenSSL for Ruby!")
      cert.sign(rsa, Digest::SHA1.new)
    end
    [ rsa, cert ]
  end
end

class HttpServer
  CRLF = "\r\n"
  def initialize (host, port, logger, allow_hosts)
    @host = host
    @port = port
    @logger = logger
    @allow_hosts = allow_hosts

    @server = TCPServer.new("0.0.0.0", port)
    @status = :stop
    @max_sessions = 5
    @timeout = 600
  end

  def parse_header (socket)
    request = socket.gets(CRLF)
    return nil, nil, nil if request.nil?

    header = Hash.new
    key = nil
    while line = socket.gets(CRLF).xchomp
      break if line == ""
      if m = /^(.*?):\s*(.*)/.match(line)
        key = m[1]
        value = m[2]
        header[key.downcase] = value
      elsif key
        header[key.downcase] += value
      end
    end
    method, url, http_version = request.split(/\s/)
    return method, URI.parse(url), header
  end

  def parse_query_internal (vars, query)
    unless query.nil?
      query.split("&").each {|key_value|
        key, value = key_value.split("=")
        vars[key.intern] = value.to_s.unescapeURL
      }
    end
  end

  def parse_query (method, url, header, socket)
    vars = Hash.new
    parse_query_internal(vars, url.query)
    content_length = (header['content-length'] or 0).to_i
    if method.downcase == "post" and content_length > 0
      data = socket.read(content_length)
      parse_query_internal(vars, data)
    end
    return vars
  end

  def customize_socket (socket)
    class << socket
      alias_method(:orig_write, :write)
      def write (str)
        n = orig_write(str)
        @nbytes_sent = nbytes_sent + n
        return n
      end

      def nbytes_sent
        @nbytes_sent ||= 0
        @nbytes_sent
      end
      private :print, :printf, :puts, :syswrite, :putc
    end
  end

  def accept
    @server.accept
  end

  def close_socket (socket)
    socket.close
  end

  def validate_access (socket, remote_host)
    return if socket.peer_hostname and @allow_hosts.match(socket.peer_hostname)
    return if socket.peer_address and @allow_hosts.match(socket.peer_address)
    raise "access denied: " + remote_host
  end

  def process_session (socket, block)
    begin
      remote_host = (socket.peer_hostname or socket.peer_address)
      @logger.vlog "Connected: #{remote_host}"

      validate_access(socket, remote_host)
      customize_socket(socket)

      timeout(@timeout) {
        method, url, header = parse_header(socket)
        if method and url and header
          vars = parse_query(method, url, header, socket)

          start_time = Time.now
          block.call(socket, method, url, header, vars)
          @logger.log sprintf("%s: %s %s \"%s\" [%.2f sec] [%d bytes sent]",
                              remote_host, method, url.to_s,
                              (header['user-agent'] or ""),
                              Time.now - start_time,
                              socket.nbytes_sent)
        end
      }
    rescue TimeoutError
      @logger.vlog "Connection timed out: #{remote_host}"
    rescue => e
      @logger.vlog e.message
    ensure
      close_socket(socket)
      @logger.vlog "Closed: #{remote_host}"
    end
  end

  public
  def start (&block)
    raise "server already started" if @status != :stop
    @logger.log sprintf("Server started at %s:%d [%d]",
                        @host, @port, Process.pid)
    running_sessions = []
    @status = :running
    while @status == :running
      begin 
        socket = accept
        t = Thread.start(socket) {|s|
          process_session(s, block)
        }
        t.abort_on_exception = true
	running_sessions << t
      rescue Errno::EBADF, Errno::ECONNABORTED, 
          Errno::EINVAL, URI::InvalidURIError
      rescue => e 
        @logger.log "#{e.message}\n#{e.backtrace}"
        if e.message == "SSL_accept:decryption failed or bad record mac"
          # this error occurrs if mobileimap is restarted
          # while Netscape/Mozilla remembers the SSL key and cert info.
          @logger.log "Please restart your web browser to solve the problem"
        end
      end
      running_sessions.delete_if {|t| t.status == false }
      if running_sessions.length >= @max_sessions
        ThreadsWait.new(running_sessions).next_wait
      end
    end
    running_sessions.each {|t| t.join }
  end

  def shutdown
    @logger.log sprintf("Server stopped [%d]", Process.pid)
    @server.close
    @status = :shutdown
  end
end

class HttpsServer < HttpServer
  def initialize (host, port, logger, allow_hosts,
                  key_file_name = nil,
                  cert_file_name = nil)
    super(host, port, logger, allow_hosts)
    @ssl_context = OpenSSL::SSL::SSLContext.new("SSLv23")
    @ssl_context.key, @ssl_context.cert = 
      OpenSSL::get_key_and_cert(key_file_name,
                                cert_file_name)
  end

  def accept
    socket = super
    ssl = OpenSSL::SSL::SSLSocket.new(socket, @ssl_context)
    begin
      ssl.accept
    rescue => e
      socket.close
      raise e
    end
    ssl
  end

  def close_socket (ssl)
    ssl.close
    ssl.io.close
  end
end

class SimpleHtmlGenerator
  def method_missing (symbol, *args)
    element = symbol.to_s
    if block_given?
      if args.empty?
        "<#{element}\n>" + yield + "</#{element}\n>"
      else
        "<#{element} " +
          args.first.map {|key, value| 
            sprintf('%s="%s"', key.to_s, value.to_s.escapeHTML)
          }.join(" ") + 
          "\n>" + yield +  "</#{element}\n>"
      end
    else
      if args.empty?
        "<#{element} /\n>"
      else
        "<#{element} " +
          args.first.map {|key, value|
            sprintf('%s="%s"', key.to_s, value.to_s.escapeHTML)
          }.join(" ") + 
          " /\n>"
      end
    end
  end
end

class ImapQuery
  private
  def initialize (vars, default_folder)
    @vars = vars
    @default_folder = default_folder
  end

  public
  def command
    @vars[:command] or "summary"
  end

  def folder
    @vars[:folder] or @default_folder
  end

  def start
    if @vars[:start] then @vars[:start].to_i else 1 end
  end

  def fstart
    if @vars[:fstart] then @vars[:fstart].to_i else 1 end
  end

  def max
    if @vars[:max] then @vars[:max].to_i else 20 end
  end

  def unseen_only
    @vars[:unseen_only] == "true"
  end

  def seq
    if @vars[:seq] then @vars[:seq].to_i else 1 end
  end

  def part
    @vars[:part] or "1"
  end

  def citation
    @vars[:citation] == "true"
  end

  def reply
    @vars[:reply] == "true"
  end

  def forward
    @vars[:forward] == "true"
  end

  def to
    NKF.nkf('-SeX', (@vars[:to] or ""))
  end

  def cc
    NKF.nkf('-SeX', (@vars[:cc] or ""))
  end

  def subject
    NKF.nkf('-SeX', (@vars[:subject] or ""))
  end

  def from
    NKF.nkf('-SeX', (@vars[:from] or ""))
  end

  def body
    NKF.nkf('-SeX', (@vars[:body] or ""))
  end

  def fsearch
    NKF.nkf('-SeX', (@vars[:fsearch] or ""))
  end

  def search
    NKF.nkf('-SeX', (@vars[:search] or ""))
  end
end

module Net
  class IMAP
    def fetch_attr (seq, attr)
      fetch(seq, attr).first.attr[attr]
    end

    def seen? (seq)
      fetch_attr(seq, "FLAGS").include?(:Seen)
    end

    def mark_seen (seq)
      store(seq, "+FLAGS", [:Seen])
    end
  end
end

module Process
  def exist? (pid)
    begin
      Process.kill(0, pid) 
      true
    rescue Errno::ESRCH
      false
    end
  end
  module_function :exist?
end

class ImapWeb
  include MobileImap

  ADDRESS_REGEX = 
    /(("?)[-0-9a-zA-Z_.+?\/]+\2@[-0-9a-zA-Z]+\.[-0-9a-zA-Z.]+)/ #/"
  ML_PREFIX_REGEX = /^[\[\(]([^\]]+?)[: ]\s*\d+[\]\)]/

  def self.validate_authentication(host, port, user, auth, password, use_ssl)
    imap = Net::IMAP.new2(host, port, use_ssl)
    imap.authenticate2(auth, user, password)
    imap.logout
    imap.disconnect
  end

  def initialize (writer, base_url, config = {})
    @writer = writer
    @base_url = base_url
    @host = config[:imap_host]
    @port = config[:imap_port]
    @auth = config[:imap_auth]
    @user = config[:imap_user]
    @use_ssl = config[:imap_ssl]
    @password = config[:imap_password]
    @from = encode_field(config[:from])
    @from_address = (collect_addresses(@from).first or "")
    @smtp_host = config[:smtp_host]
    @smtp_port = config[:smtp_port]
    @folder_include = config[:folder_include]
    @folder_exclude = config[:folder_exclude]
    @default_folder_prefix = config[:default_folder_prefix]
    @subscribed_only = config[:subscribed_only]
    @signature_file_name = config[:signature_file_name]

    @default_folder = config[:default_folder]
    @default_folder = encode_imap_utf7(@default_folder) if @default_folder
    @fcc_folder = config[:fcc_folder]
    @fcc_folder = encode_imap_utf7(@fcc_folder) if @fcc_folder

    @query = nil
    @client_width = config[:default_client_width]
    @max_body_length = 4096
    
    @seq_color = "#008822"
    @mark_color = "#8822ff"
    @seq_color = "#008822"
    @date_color = "#8844cc"
    @citation_color = "#666666"
    @from_color = "#aa6622"
    @to_color = "#666600"
    @subject_color = "#446622"
    @footer_color = "#888888"
    @field_name_color = "#cc2222"
    @field_value_color = "#777777"
    @search_form_color = "#cc4400"
    @emphasis_color = "#ff0000"

    @envelope_cache = Hash.new
    @messages_cache = nil
  end

  private
  def get_field (seq, name)
    envelope = (@envelope_cache[seq] or @imap.fetch_attr(seq, "ENVELOPE"))
    @envelope_cache[seq] = envelope
    value = if envelope.respond_to?(name)
              envelope.send(name)
            else # :references, :x-mailer, etc.
              name2 = name.to_s.upcase
              v = @imap.fetch_attr(seq, "BODY[HEADER.FIELDS (#{name2})]")
              v.sub(/^#{name2}:\s*/i, "")
            end
    if value.kind_of?(String)
      value.safe_toeuc.gsub(/\r\n\s+/, "") # concat multi-line field
    else
      value
    end
  end

  def get_subject (seq)
    subject = get_field(seq, :subject)
    if subject and !subject.empty?
      subject
    else
      "(無題)"
    end
  end

  def remove_comment_in_field (field)
    field = field.safe_toeuc
    true while field.sub!(/\([^()]*?\)/, "")
    field
  end

  def collect_addresses (field)
    addresses = []
    if field
      parts = remove_comment_in_field(field).split(',')
      parts.each {|part|
        if m = (/<(.*?)>/.match(part) or ADDRESS_REGEX.match(part))
          addresses.push(m[1])
        end
      }
    end
    return addresses.uniq
  end

  def get_addresses (addresses)
    if (!addresses) or addresses.empty?
      []
    else
      addresses.map {|a| a.mailbox + "@" + a.host }
    end
  end

  def get_name (addresses)
    if (!addresses) or addresses.empty?
      ""
    else
      (addresses.first.name or "").safe_toeuc.strip.gsub(/^"(.*)"$/, '\1')
    end
  end

  def get_from_address (seq)
    (get_addresses(get_field(seq, :from)).first or "")
  end

  def get_to_address (seq)
    (get_addresses(get_field(seq, :to)).first or "")
  end

  def get_cc_addresses (seq)
    addresses = get_addresses(get_field(seq, :cc)) + 
      get_addresses(get_field(seq, :to))
    addresses.delete(@from_address)
    addresses.delete(get_reply_to_address(seq))
    addresses.uniq.join(', ')
  end

  def get_reply_to_address (seq)
    (get_addresses(get_field(seq, :reply_to)).first or "")
  end

  def get_from_name (seq)
    name = get_name(get_field(seq, :from))
    if name.empty?
      get_from_address(seq)
    else
      name
    end
  end

  def get_compact_date (seq)
    date = get_field(seq, :date)
    if date
      begin 
        Time.parse(date).getlocal.strftime("%m/%d %H:%M")
      rescue
        Time.now.strftime("%m/%d %H:%M")
      end
    else
      ""
    end
  end

  def generate_url (args = {})
    #
    # file_name should be placed at the end of parameters
    # because some browsers doesn't understand the
    # Content-Disposition: field and instead relies the last
    # parameter in URL for obtaining file name information.
    #
    parameters = args.keys.find_all {|key|
      key != :file_name and args[key].to_s != ""
    }
    parameters.push(:file_name) if args[:file_name]

    url = ""
    url << @base_url.path
    unless parameters.empty?
      url << "?" + parameters.map {|key|
        key.to_s.escapeURL + "=" + NKF.nkf('-EsX', args[key].to_s).escapeURL
      }.join("&")
    end
    return url
  end

  # preserve some variables
  def generate_url2 (args = {})
    [:folder, :search, :unseen_only, :seq].each {|key|
      args[key] = @query.send(key) unless args.include?(key)
    }
    generate_url(args)
  end

  def compact_from (from, width)
    if from.length <= width 
      from else from[0, width - 3] + "..." 
    end
  end

  def compact_subject (subject)
    subject = subject.gsub(ML_PREFIX_REGEX, '[\1]')
    if subject.length <= @client_width * 2 
      subject 
    else 
      subject.cut(@client_width * 2 - 3 - 4) + "..." # - 4 for word wrapping
    end
  end

  def compact_body (body)
    if body.length <= @max_body_length
      body
    else
      body.cut(@max_body_length) + "\r\n(以下省略)\r\n"
    end
  end

  def generate_mark_and_number (g, seq, nmessages)
    mark = if @imap.seen?(seq) then "■" else "□" end
    sprintf("%s%03d", mark, nmessages - nth(seq) + 1)
  end

  def generate_date_line (g, seq, nmessages)
    g.font(:color => @seq_color) { 
      generate_mark_and_number(g, seq, nmessages)    
    } + " " +
      g.font(:color => @date_color) { get_compact_date(seq).escapeHTML } + g.br
  end

  def multipart? (seq)
    structure = get_body_structure(seq)
    structure.is_a?(Net::IMAP::BodyTypeMultipart)
  end

  def generate_from_line (g, seq, nmessages)
    prefix = generate_mark_and_number(g, seq, nmessages)
    width = @client_width - prefix.length - 1
    g.font(:color => @seq_color) { prefix } + 
      if multipart?(seq) 
        g.font(:color => @mark_color) { "@" } 
      else
        " "
      end +
    g.font(:color => @from_color) { 
      emphasize(g, compact_from(get_from_name(seq), width).escapeHTML)
    } + g.br
  end

  def emphasize (g, str)
    if @query.search.empty?
      str
    else
      re = Regexp.new(Regexp.escape(@query.search.escapeHTML),
                      Regexp::IGNORECASE)
      str.gsub(re, g.font(:color => @emphasis_color) { g.strong { '\0' } })
    end
  end

  def generate_list (g, nmessages, messages)
    (messages.reverse[@query.start - 1, @query.max] or []).collect {|seq|
      url = generate_url2(:command => "view",
                          :seq => seq)
      begin
        generate_from_line(g, seq, nmessages) +
          g.a(:href => url) { 
          emphasize(g, compact_subject(get_subject(seq)).escapeHTML)
        } + g.hr
      rescue Exception => e
        "Error: " + e.to_html_simple + g.hr
      end
    }.join
  end

  def generate_navi (g, symbol, prev, nxet, preserve_vars)
    current = @query.send(symbol)

    navi = []
    if prev and prev != current
      vars = { symbol => prev}
      preserve_vars.each {|key| vars[key] = @query.send(key) }
      url = generate_url(vars)
      navi.push(g.a(:href => url) { "←" })
    end

    if nxet and nxet != current
      vars = { symbol => nxet}
      preserve_vars.each {|key| vars[key] = @query.send(key) }
      url = generate_url(vars)
      navi.push(g.a(:href => url) { "→" })
    end

    return navi.join
  end

  def calc_prev_and_next (current, unit, max)
    return current, current if max <= unit

    prev = if current > unit and current <= max
             current - unit
           else
             ((max - 1) / unit) * unit + 1
           end
    nxet = if current + unit - 1 < max
             current + unit
           else
             1
           end
    return prev, nxet
  end

  def generate_seen_mode (g)
    if @query.command == "summary"
      all_url = generate_url(:folder => @query.folder, # ommit :command
                             :search => @query.search,
                             :unseen_only => false)
      unseen_url = generate_url(:folder => @query.folder,
                                :search => @query.search,
                                :unseen_only => true)
    elsif @query.command == "folders"
      all_url = generate_url(:command => @query.command,
                             :fsearch => @query.fsearch,
                             :unseen_only => false)
      unseen_url = generate_url(:command => @query.command,
                                :fsearch => @query.fsearch,
                                :unseen_only => true)
    else
      raise "Unexpected command: #{@query.command}"
    end

    if @query.unseen_only then
      g.a(:href => all_url) { "全部" } + " " + "未読"
    else
      "全部" + " " + g.a(:href => unseen_url) { "未読" }
    end
  end

  def ascii? (str)
    if /^[\x00-\x7f]+$/.match(str) then true else false end
  end

  def get_messages
    unless @messages_cache
      if @query.search.empty?
        @messages_cache = (1..get_nmessages_real).to_a
      else
        if ascii?(@query.search) 
          charset = nil 
          search_query = @query.search
        else
          charset = "iso-2022-jp" 
          search_query = @query.search.tojis
        end
        @messages_cache = ["BODY", "FROM", "SUBJECT"].map {|field|
          @imap.search([field, search_query], charset)
        }.flatten.uniq.sort
      end
      @messages_cache &= @imap.search(["UNSEEN"]) if @query.unseen_only
    end
    return @messages_cache
  end

  def get_nmessages_real
    @imap.status(@query.folder, ["MESSAGES"])["MESSAGES"]
  end

  def get_nmessages
    if normal_view?
      get_nmessages_real
    else
      get_messages.length
    end
  end

  def get_unseen_nmessages (folder)
    if @query.search.empty?
      begin
        @imap.status(folder, ["UNSEEN"])["UNSEEN"]
      rescue Net::IMAP::NoResponseError
	0
      end
    else
      (get_messages & @imap.search(["UNSEEN"])).length
    end
  end

  def get_body_structure (seq)
    @imap.fetch_attr(seq, "BODYSTRUCTURE")
  end

  def get_part_structure (structure, part_id)
    value = nil
    part_id.split(".").map {|x| x.to_i - 1}.each {|i|
      value = structure.parts[i]
      structure = value
    }
    return value
  end

  def get_body (seq, part_id = "1")
    encoding   = "7bit"
    media_type = "TEXT"
    structure = get_body_structure(seq)
    if structure.is_a?(Net::IMAP::BodyTypeMultipart)
      part = get_part_structure(structure, part_id)
      if part.respond_to?(:encoding) and part.respond_to?(:media_type)
        encoding = part.encoding
        media_type = part.media_type
      end
    else
      encoding = (get_field(seq, "content-transfer-encoding".intern) or 
                  encoding)
    end

    body = @imap.fetch_attr(seq, "BODY[#{part_id}]").collect.join
    if encoding.downcase == "base64"
      body = body.unpack('m*').first
    elsif encoding.downcase == "quoted-printable"
      body.gsub!(/=\r\n/, '')   # remove soft line breaks
      body.gsub!(/=[\r\n]/, '') 
      body = body.unpack('M*').first
    end
    if media_type == "TEXT"
      body.safe_toeuc
    else
      body
    end
  end

  def get_attachment (seq, part_id)
    begin
      attachment = get_body(seq, part_id)
      structure = get_body_structure(seq)
      part = get_part_structure(structure, part_id)
      raise if part.nil?
    rescue 
      no_such_part
      return
    end

    content_type = sprintf("%s/%s", 
                           part.media_type,
                           part.subtype).downcase
    file_name = get_part_file_name(part)
    return attachment, content_type, file_name
  end

  def add_link (g, line)
    line.gsub(/(\+81-)?(\d[\d-]{8,12})/) {|tel|
      number = if $1 then "0" else "" end + $2.gsub(/-/, "").escapeURL
      g.a(:href => "tel:#{number}") { tel }
    }.gsub(ADDRESS_REGEX) {|address|
      g.a(:href => "mailto:#{address}") { address }
    }
  end

  def nbsp (str)
    str.untabify.gsub(/  /, "　").sub(/^ /, "&nbsp;")
  end

  def get_part_file_name (part)
    if part.disposition and part.disposition.param
      part.disposition.param["FILENAME"]
    elsif part.param
      part.param["NAME"]
    else
      nil
    end
  end

  def generate_attachment_links (g, seq)
    structure = get_body_structure(seq)
    links = generate_attachment_links_internal(g, seq, structure, "")
    links = g.hr + links unless links.empty?
    return links
  end

  def generate_attachment_links_internal (g, seq, structure, prefix)
    links = ""
    if structure.is_a?(Net::IMAP::BodyTypeMultipart)
      structure.parts.each_with_index {|part, id|
        id += 1
        if part.is_a?(Net::IMAP::BodyTypeMultipart)
          links << generate_attachment_links_internal(g, seq, part, 
                                                      prefix + id.to_s + ".")
          next
        end
        next unless part.size
        file_name = get_part_file_name(part)
        next unless file_name
        url = generate_url2(:file_name => file_name.tosjis,
                            :command => "download",
                            :seq => seq,
                            :part => prefix + id.to_s)
        size = part.size * 3 / 4 / 1024 # size of the decoded data
        links << g.a(:href => url) { file_name.safe_toeuc } + 
          sprintf(" %dKB" + g.br, size)
      }
    end
    return links
  end

  def generate_body (g, seq)
    body = ""
    compact_body(get_body(seq)).each_line {|line|
      line = emphasize(g, line.escapeHTML)
      line = if /\A>/.match(line)
               g.font(:color => @citation_color) { 
                 add_link(g, nbsp(line)) } + g.br
             else
               add_link(g, nbsp(line)) + g.br
             end
      if (body.length + line.length) > @max_body_length
        body << "\r\n(以下省略)\r\n"
        break
      else
        body << line
      end
    }
    body << generate_attachment_links(g, seq)
    return g.tt { body }
  end

  def generate_re_subject (subject, space = "")
    "Re:" + space + subject.sub(/^(Re:\s*)+/, "")
  end

  def generate_mailto_url (address, subject)
    mailto = "mailto:" + address + 
      "?subject=" + generate_re_subject(subject).tosjis.escapeURL
  end

  def simplify_folder_name (folder)
    new = folder.sub(/^INBOX\./, "") # for courier-imapd
    new.sub!(/^#{@default_folder_prefix}/, "") # for uw-imapd etc.
    new = decode_imap_utf7(new) 
    new.sub(/^INBOX$/, "受信箱")
  end

  def get_folders 
    pattern = @default_folder_prefix + "*"
    folders = (["INBOX"] + @imap.list("", pattern).find_all {|f|
                 !f.attr.include?(:Noselect)
               }.map {|f| f.name }.find_all {|f|
                 decoded_name = decode_imap_utf7(f)
                 @folder_include.match(decoded_name) and 
                   (!@folder_exclude.match(decoded_name))
               }.sort).uniq
    unless @query.fsearch.empty?
      re = Regexp.new(Regexp.escape(@query.fsearch),  Regexp::IGNORECASE)
      folders = folders.find_all {|f|
        decoded_name = decode_imap_utf7(f)
        re.match(decoded_name)
      }
    end

    if @subscribed_only
      # FIXME: The reason why we should do the redundant
      # process is that LSUB of uw-imapd returns folders
      # having :Noselect flags.
      seen = Hash.new; folders.each {|f| seen[f] = true }
      folders = 
        @imap.lsub("", pattern).map {|f| f.name }.find_all {|f|
        seen[f] }.uniq.sort
    end
    return folders
  end

  def generate_reply_line (g, mailto, seq)
    url = generate_url2(:command => "compose", 
                        :seq => seq,
                        :citation => false,
                        :reply => true)
    g.a(:href => mailto) { "端末で返信" } + " " +
    g.a(:href => url) { "Webで返信" }
  end

  def get_reply_address (seq)
    get_reply_to_address(seq) or get_from_address(seq) or ""
  end

  def generate_meta (g)
    g.meta(:name => "robots", :content => "noindex,nofollow") +
      g.meta(:name => "robots", :content => "noarchive")
  end

  def get_ml_name (seq)
    if name = get_field(seq, "x-ml-name".intern) and !name.empty?
      return name
    elsif name= get_field(seq, "mailing-list".intern) and !name.empty?
      return m[1] if m = /<(.*)>/.match(name)
    end
    return nil
  end

  def link_ml_folder (g, seq, subject)
    subject.sub(ML_PREFIX_REGEX) {|s|
      ml_prefix = $1
      ml_name = get_ml_name(seq)
      ml_name = ml_prefix if ml_name.nil?
      re1 = /\b#{Regexp.quote(ml_name)}$/   # "foo.bar" => /\bfoo\.bar$/
      re2 = /\b#{ml_name.gsub(/\W/, ".")}$/ # "foo-bar@ml" -> "\bfoo.bar.ml$"
      ml_folder = get_folders.find {|folder|
        re1.match(folder) or re2.match(folder)
      }
      if ml_folder
        s.sub(/#{ml_prefix}/) {|x|
          g.a(:href => generate_url(:folder => ml_folder,
                                    :command => "summary")) { x }
        }
      else
        s
      end
    }
  end

  def nth (seq)
    if normal_view?
      seq
    else
      messages = get_messages
      n = (0...messages.length).find {|i| messages[i] >= seq }
      if n then return n + 1 else messages.length end
    end
  end

  def calc_current_start (nmessages, seq)
    (nmessages - nth(seq)) / @query.max * @query.max + 1
  end

  def command_download (socket, header)
    @imap.select(@query.folder)
    unless mail_exist?(@query.seq) then no_such_mail; return; end

    attachment, content_type, file_name = 
      get_attachment(@query.seq, @query.part)
    @writer.print(attachment, content_type,
                  "Content-Disposition" => 
                  "filename=\"#{file_name.tosjis}\"")
  end

  def mail_exist? (seq)
    seq > 0 and @imap.fetch(seq, "UID") != nil
  end

  def no_such_something (what, command, seq)
    g = SimpleHtmlGenerator.new
    html = g.html {
      g.head {
        generate_meta(g) +
        g.title { "#{what}が見つかりません" }
      } + g.body {
        "#{what}が見つかりません" + g.hr +
        g.a(:href => generate_url2(:command => command,
                                   :seq => seq)) { "戻る" }
      }
    }
    @writer.print(html)
  end

  def no_such_mail
    no_such_something("メール", "summary", nil)
  end

  def no_such_folder
    no_such_something("フォルダ", "folders", nil)
  end

  def no_such_part
    no_such_something("添付ファイル", "view", @query.seq)
  end

  def no_such_command
    no_such_something("コマンド", "summary", nil)
  end

  def normal_view?
    @query.search.empty? and @query.unseen_only == false
  end

  def command_view (socket, header)
    @imap.select(@query.folder)
    unless mail_exist?(@query.seq) then no_such_mail; return; end

    nmessages = get_nmessages
    start = calc_current_start(nmessages, @query.seq)
    reply_address = get_reply_address(@query.seq)
    mailto = generate_mailto_url(reply_address, get_subject(@query.seq))

    if normal_view?
      nxet, prev = calc_prev_and_next(@query.seq, 1, nmessages)
    else
      messages = get_messages
      prev = (messages.find {|x| x > @query.seq } or messages.first)
      nxet = (messages.find_all {|x| x < @query.seq }.last or messages.last)
    end

    g = SimpleHtmlGenerator.new
    navi = generate_navi(g, :seq, prev, nxet,
                         [:command, :folder, :search, :unseen_only])
    
    html = g.html {
      g.head {
        generate_meta(g) +
        g.title { get_subject(@query.seq).escapeHTML }
      } + g.body { 
        g.div {
          g.a(:name => "top") { generate_date_line(g, @query.seq, 
                                                   nmessages) } + 
            g.font(:color => @from_color) { 
            emphasize(g, get_from_name(@query.seq).escapeHTML) } + 
            g.br +
            g.font(:color => @subject_color) { 
            link_ml_folder(g, @query.seq, 
                           emphasize(g, get_subject(@query.seq).escapeHTML))
          } +
            g.br + navi + " " + 
            g.a(:href => generate_url2(:command => "summary",
                                       :seq => nil,
                                       :start => start)) { "メール一覧" } + 
            " " + g.a(:href => "#bottom") { "↓" } + g.hr + 
            generate_body(g, @query.seq) + g.hr + 
            navi +  " " + 
            g.a(:href => generate_url2(:command => "summary",
                                       :seq => nil,
                                       :start => start)) { "メール一覧" } + 
            " " + g.a(:href => "#top", :name => "bottom") { "↑" } + g.br +
            generate_reply_line(g, mailto, @query.seq) + g.br +
            g.a(:href => generate_url2(:command => "compose",
                                       :forward => true)) { "転送" } + " " +
            g.a(:href => generate_url2(:command => "header")) {"へッダ詳細" }+ 
            generate_footer(g)
        }
      }
    }
    @imap.mark_seen(@query.seq)
    @writer.print(html)
  end

  def command_header (socket, header)
    @imap.examine(@query.folder)
    unless mail_exist?(@query.seq) then no_such_mail; return; end

    header = @imap.fetch_attr(@query.seq, 'BODY[HEADER]')
    g = SimpleHtmlGenerator.new
    html = g.html {
      g.head {
        generate_meta(g) +
        g.title { "へッダ詳細" }
      } + g.body { 
        g.div {
          g.tt {
            header.map {|line|
              if m = /^(\S+:)?(.*)/.match(line.xchomp)
                if m[1]
                  g.font(:color => @field_name_color) { nbsp(m[1].escapeHTML) }
                else
                  ""
                end +
                  g.font(:color => @field_value_color) { 
                    nbsp(m[2].escapeHTML) 
                  } +
                  g.br
              else
                ""
              end
            }.join 
          } + g.hr +
            g.a(:href => generate_url2(:command => "view")) { "戻る" } + 
            generate_footer(g)
        } 
      }
    }
    @writer.print(html)
  end

  def generate_footer (g)
    g.hr +
    g.font(:color => @footer_color) {
      "mobileimap #{MobileImap::VERSION}" + if @writer.encoding
                                              " (" + @writer.encoding + ")"
                                            else
                                              ""
                                            end
    }
  end

  def calc_current_fstart
    folders = if @query.unseen_only
                get_folders.find_all {|f| get_unseen_nmessages(f) > 0 }
              else
                get_folders
              end
    i = ((0 ... folders.length).find {|i| folders[i] == @query.folder } or 0)
    i / @query.max * @query.max + 1
  end

  def generate_new_mail_line (g)
    g.a(:href => 
        generate_url2(:command => "compose")) { 
      "新規メール作成" }
  end

  def command_summary (socket, header)
    begin
      @imap.select(@query.folder)
    rescue Net::IMAP::ResponseError
      no_such_folder
      return
    end
    messages = get_messages
    unseen_nmessages = get_unseen_nmessages(@query.folder)
    nmessages = get_nmessages
    title = "mobileimap: " + simplify_folder_name(@query.folder)
    h1 = sprintf("%s: %d/%d通", simplify_folder_name(@query.folder), 
                 unseen_nmessages,
                 nmessages)
    fstart = calc_current_fstart
    prev, nxet = calc_prev_and_next(@query.start, @query.max, nmessages)

    g = SimpleHtmlGenerator.new
    navi = generate_navi(g, :start, prev, nxet,
                         [:command, :folder, :search, :unseen_only])

    html = g.html {
      g.head {
        generate_meta(g) +
        g.title { title.escapeHTML }
      } + g.body { 
        g.div {
          g.a(:name => "top") { 
            g.h1 { h1.escapeHTML } 
          } + navi + " " + 
            g.a(:href => generate_url(:command => "folders",
                                      :unseen_only => @query.unseen_only,
                                      :fstart => fstart)) {"フォルダ一覧"} +
            " " + g.a(:href => "#bottom") { "↓" } + 
            g.br + generate_seen_mode(g) + g.hr +
            generate_search_form(g) +
            generate_list(g, nmessages, messages) + 
            navi + " " + 
            g.a(:href => generate_url(:command => "folders",
                                      :unseen_only => @query.unseen_only,
                                      :fstart => fstart)) {"フォルダ一覧"} +
            " " + g.a(:href => "#top", :name => "bottom") { "↑" }  + g.br +
            generate_seen_mode(g) + " " + g.br + 
            generate_new_mail_line(g) + generate_footer(g)
        } 
      }
    }
    @writer.print(html)
  end

  def generate_citation_line (g, seq)
    if @query.citation or @query.reply == false
      ""
    else
      g.a(:href => generate_url2(:command => "compose", 
                                 :citation => true,
                                 :reply => true,
                                 :seq => seq)) {
        "本文を引用"
      } + g.hr
    end
  end

  def generate_cited_body (seq)
    get_from_name(seq) + ":" + "\n\n" + 
      compact_body(get_body(seq)).map {|line| "> " + line }.join.escapeHTML
  end

  def generate_forward_body (seq)
    body = ""
    [:to, :subject, :from, :cc, :date].each {|key|
      value = get_field(seq, key)
      value = get_addresses(value).join(', ') unless value.kind_of?(String)
      if value and !value.empty?
        body << key.to_s.capitalize + ": " + value + "\n"
      end
    }
    body << "\n"
    body << compact_body(get_body(seq))
    body.escapeHTML
  end

  def command_compose (socket, header)
    @imap.examine(@query.folder)
    if @query.reply
      unless mail_exist?(@query.seq) then no_such_mail; return; end
    end

    to_address = if @query.reply then get_reply_address(@query.seq) else "" end
    cc_addresses= if @query.reply then get_cc_addresses(@query.seq) else "" end
    subject = if @query.reply
                generate_re_subject(get_subject(@query.seq), " ") 
              elsif @query.forward
                "Forward: " + get_subject(@query.seq)
              else
                "" 
              end
    body = if @query.citation and @query.reply
             generate_cited_body(@query.seq) 
           elsif @query.forward
             generate_forward_body(@query.seq)
           else
             ""
           end

    signature = read_signature_file(@signature_file_name)
    body << "\n"
    body << compact_body(signature)
    body.escapeHTML

    url = generate_url2(:command => "send",
                        :reply => @query.reply,
                        :forward => @query.forward)
    title = if @query.reply 
              "メール返信" 
            elsif @query.forward
              "メール転送"
            else 
              "メール作成" 
            end
    width = @client_width - 2
    height = @client_width / 4
    g = SimpleHtmlGenerator.new
    html = g.html {
      g.head {
        generate_meta(g) +
        g.title { title }
      } + g.body { 
        g.div {
          generate_citation_line(g, @query.seq) + 
            g.form(:method => 'post',
                   :action => url) {
            g.input(:type => 'hidden', :name => 'command', :value => 'send') +
              g.font(:color => @field_name_color) { '件名: ' } + 
              g.br + g.input(:type => 'text', :size => width, 
                             :name => 'subject', 
                             :value => subject) + g.br +
              g.font(:color => @field_name_color) { '宛先: ' } + 
              g.br + g.input(:type => 'text', :size => width, 
                             :name => 'to', 
                             :value => to_address) + g.br +
              g.font(:color => @field_name_color) { '同報: ' } + 
              g.br + g.input(:type => 'text', :size => width, 
                             :name => 'cc', :value => cc_addresses) + g.br +
              g.font(:color => @field_name_color) { '差出人: ' } + 
              g.br + g.input(:type => 'text', :size => width, 
                             :name => 'from', 
                             :value => @from) + g.br +
              g.font(:color => @field_name_color) { '本文: ' } + g.br +
              g.textarea(:name => 'body', :rows => height, 
                         :cols => width) { body } + g.br +
              g.submit(:value => '送信') +
              g.input(:type => 'submit', :value => '送信')
          } + g.hr + 
            g.a(:href => generate_url2(:command => 
                                       if @query.reply == true or
                                           @query.forward
                                         "view" 
                                       else 
                                         "summary" 
                                       end)) { "戻る" } + 
            generate_footer(g)
        }
      }
    }
    @writer.print(html)
  end

  def encode_field (field)
    field.gsub(/[　-瑤]\S*\s*/) {|x|
      x.scan(/.{1,10}/).map {|y|
        "=?iso-2022-jp?B?" + y.tojis.to_a.pack('m').chomp + "?="
      }.join("\n ")
    }
  end

  def send_mail (message)
    recipients = []
    recipients.concat(collect_addresses(@query.to))
    recipients.concat(collect_addresses(@query.cc))

    Net::SMTP.start(@smtp_host, @smtp_port, Socket.gethostname) {|smtp|
      smtp.send_mail(message, @from_address, recipients)
    }
  end

  def generate_message_id
    sprintf("<%d.%d.%d@%s>", 
            Process.pid, Time.now.to_i, self.object_id, Socket.gethostname)
  end

  def add_in_reply_to_and_references (message)
    @imap.examine(@query.folder)
    message_id = get_field(@query.seq, :message_id)
    if message_id and !message_id.empty?
      message << "In-Reply-To: #{message_id}\n" 
      references =  get_field(@query.seq, :references)
      if references and !references.empty?
        list = [message_id] + references.scan(/<.*?>/)
        message << "References: " + list.join("\n\t") + "\n"
      end
    end
  end

  def create_message (header)
    user_agent = (header['user-agent'] or "")
    date = Time.now.rfc2822

    message_id = generate_message_id
    message = ''
    message << "Subject: #{encode_field(@query.subject)}\n"
    message << "To: #{encode_field(@query.to)}\n"
    message << "Cc: #{encode_field(@query.cc)}\n" unless @query.cc.empty?
    message << "From: #{encode_field(@query.from)}\n"
    message << "Date: #{date}\n"
    message << "Content-Type: text/plain; charset=iso-2022-jp\n"
    message << "Content-Transfer-Encoding: 7bit\n"
    message << "Message-ID: #{message_id}\n"
    message << "X-Mailer: mobileimap #{MobileImap::VERSION} (#{user_agent})\n"
    add_in_reply_to_and_references(message) if @query.reply
    message << "\n"
    message << @query.body.tojis
  end

  def command_send (socket, header)
    begin
      message = create_message(header)
      # Net::SMTP#send_mail requires a LF message.
      send_mail(message)
      # but Net::IMAP#append requires a CRLF message.
      if @fcc_folder
        @imap.select(@fcc_folder)
        @imap.append(@fcc_folder, message.gsub(/\n/, "\r\n"))
      end
      url = if @query.reply or @query.forward
              generate_url2(:command => "view")
            else
              generate_url2(:command => "summary")
            end
      g = SimpleHtmlGenerator.new
      html = g.html {
        g.head {
          g.title { "送信完了" }
        } + g.body { g.p {
          "送信が完了しました" + g.br + g.a(:href => url) { "戻る" }
        } }
      }
      @writer.print(html)
    rescue Exception => e
      g = SimpleHtmlGenerator.new
      html = g.html {
        g.head {
          g.title { "送信失敗" }
        } + g.body { g.p {
          "送信に失敗しました" + g.br + e.to_html
        } }
      }
      @writer.print(html)
    end
  end

  def generate_search_form_common (g, title, command, xsearch, xstart, xvalue)
    g.form(:method => 'get',
           :action => generate_url) {
      g.p{ g.font(:color => @search_form_color) { title } + g.br +
          g.input(:type => 'hidden', :name => 'command', 
                  :value => command) +
          g.input(:type => 'hidden', :name => xstart, 
                  :value => 1) +
          g.input(:type => 'text', 
                  :size => @client_width - 2 - 5, 
                  :name => xsearch, 
                  :value => xvalue) +
          [:folder, :unseen_only].map {|key|
            if @query.send(key)
              g.input(:type => 'hidden', :name => key.to_s, 
                      :value => @query.send(key).to_s)
            else
              ""
            end
          }.join('') + g.input(:type => 'submit', :value => '送信')
      }
    }
  end

  def generate_fsearch_form (g)
    generate_search_form_common(g, 'フォルダ名検索: ', 'folders', 
                                'fsearch', 'fstart', @query.fsearch)
  end

  def generate_search_form (g)
    generate_search_form_common(g, 'メール検索: ', 'summary',
                                'search', 'start', @query.search)
  end

  def command_folders (socket, header)
    all_folders = if @query.unseen_only
                    get_folders.find_all {|f| get_unseen_nmessages(f) > 0 }
                  else
                    get_folders
                  end
    folders = (all_folders[@query.fstart - 1, @query.max] or [])
    prev, nxet = calc_prev_and_next(@query.fstart, @query.max, 
                                    all_folders.length)

    g = SimpleHtmlGenerator.new
    navi = generate_navi(g, :fstart, prev, nxet,
                         [:command, :fsearch, :unseen_only])

    html = g.html {
      g.head {
        generate_meta(g) +
        g.title { "フォルダ一覧" }
      } + g.body { 
        g.div {
          g.tt {
            i = @query.fstart
            g.a(:name => "top") { 
              g.h1 { sprintf("フォルダ: %d個",
                             all_folders.length)  } 
            } + 
              navi + " " +
              g.a(:href => "#bottom") { "↓" } + " " +
              generate_seen_mode(g) + " " + g.hr +
              generate_fsearch_form(g) + 
              folders.map {|folder|
              line = g.font(:color => @seq_color) { sprintf("%03d", i) } + 
                if get_unseen_nmessages(folder) > 0 then 
                  g.font(:color => @mark_color) { "*" }
                else 
                  " " 
                end + 
                g.a(:href => generate_url(:folder => folder,
                                          :unseen_only => @query.unseen_only)){
                simplify_folder_name(folder)
              } + g.br
              i += 1
              line
            }.join + g.hr +
              navi + " " +
              g.a(:href => "#top", :name => "bottom") { "↑" } + " " +
              generate_seen_mode(g) + " " + 
              generate_footer(g)
          } 
        }
      }
    }
    @writer.print(html)
  end

  def configure (header)
    # "Mozilla" covers almost all popular PC web browsers
    # including Netscape, Mozilla, MSIE, Opera, Konqueror,
    # Safari, NetFront. However, AirH" Phone also identifies
    # itself as a Mozilla web browser...
    # NetFront might be a PDA web browser not PC's.
    pc_web_browser_regex = /\b(Mozilla|w3m|lynx)\b/i 
    ktai_web_browser_regex = /\b(DDIPOCKET|KDDI|PDXGW|DoCoMo|J-PHONE|ASTEL)\b/

    if header['x-up-devcap-screenchars'] # for ezweb
      @client_width = header['x-up-devcap-screenchars'].split(",").first.to_i
    elsif ktai_web_browser_regex.match(header['user-agent'])
      @client_width = @client_width 
    elsif pc_web_browser_regex.match(header['user-agent'])
      @max_body_length *= 10
      @client_width = 80
    else
      @client_width = @client_width 
    end
  end

  def read_signature_file(signature_file_name)
    begin
      return File.read(signature_file_name)
    rescue
      return ""
    end
  end

  public
  def process (socket, method, url, header, vars)
    @query = ImapQuery.new(vars, @default_folder)
    configure(header)

    begin
      @imap = Net::IMAP.new2(@host, @port, @use_ssl)
      @imap.authenticate2(@auth, @user, @password)
      command = ("command_" + @query.command).intern
      if self.respond_to?(command, true)
        self.send(command, socket, header)
      else 
        no_such_command
        return
      end
    ensure
      @imap.logout
      @imap.disconnect
    end
  end
end
    
class Logger
  def initialize (log_file, verbose_p)
    @log_file = log_file
    @log_file.sync = true
    @verbose_p = verbose_p
  end

  private
  def puts_log (msg)
    time = Time.now.strftime("%Y-%m-%dT%H:%M:%S")
    @log_file.puts "#{time}: #{msg}"
  end

  public
  def reopen
    if @log_file.respond_to?(:path)
      log_filename = @log_file.path
      @log_file.close
      @log_file = File.new(log_filename, "a")
    end
  end

  def log (msg)
    puts_log(msg)
  end

  def vlog (msg)
    puts_log(msg) if @verbose_p
  end
end

def pf (format, *args)
  printf(format + "\n", *args)
end

class Regexp
  def to_s2
    %r!/(.*)/!.match(self.inspect)[1]
  end
end

def show_usage
  config = default_config

  pf("Usage: mobileimap [OPTION]")
  pf("  -d, --daemon               run as a daemon")
  pf("  -k, --stop[=URLs]          stop daemons")
  pf("  -l, --list                 list running daemons")
  pf("  -a, --imap-auth=METHOD     use authentication METHOD for IMAP [%s]",
     config[:imap_auth])
  pf("  -u, --imap-user=USER       set the user name of IMAP to USER [%s]",
     config[:imap_user])
  pf("  -S, --imap-host=HOST       set the host name of IMAP to HOST [%s]",
     config[:imap_host])
  pf("  -P, --imap-port=PORT       set the port number of IMAP to PORT [%d]",
     config[:imap_port])
  pf("      --imap-ssl             use SSL for IMAP connection (i.e. IMAPS)")
  pf("  -s, --http-host=HOST       set the host name of HTTP to HOST [%s]",
     config[:http_host])
  pf("  -p, --http-port=PORT       set the port number of HTTP to PORT [%d]",
     config[:http_port])
  pf("      --ssl                  run as a https server")
  pf("      --ssl-key=FILE         use FILE as a key file of SSL")
  pf("      --ssl-cert=FILE        use FILE as a certification file of SSL")
  pf("      --smtp-host=HOST       set the host name of SMTP to HOST [%s]",
     config[:smtp_host])
  pf("      --smtp-port=PORT       set the port number of SMTP to PORT [%d]",
     config[:smtp_port])
  pf("  -i, --subscriber-id=ID     set the subscriber ID for ezweb to ID")
  pf("  -j, --jphone-uid=ID        set the user ID for JPHONE to ID")
  pf("  -x, --url-path=PATH        set the path part of URL to PATH")
  pf("  -f, --from=FROM            set the From: to FROM [%s]",
     config[:from])
  pf("      --signature=FILE       use the signature file")
  pf("      --folder=FOLDER        set the default folder to FOLDER [%s]",
     config[:default_folder])
  pf("      --folder-include=RE    use the regex RE to include folders [%s]",
     config[:folder_include].to_s2)
  pf("      --folder-exclude=RE    use the regex RE to exclude folders [%s]",
     config[:folder_exclude].to_s2)
  pf("      --folder-prefix=PREFIX set the default folder prefix to PREFIX [%s]",
     config[:default_folder_prefix])
  pf("      --fcc-folder=FOLDER    store sent mails to FOLDER")
  pf("      --subscribed-only      list only subscribed folders")
  pf("  -w, --client-width=WIDTH   set the default client width to WIDTH [%d]",
     config[:default_client_width])
  pf("      --allow-hosts=RE       allow accesses from hosts matching RE [%s]",
     config[:allow_hosts].to_s2)
  pf("      --mobileimaprc=FILE    specify alternate run control file")
  pf("      --dump-config          dump configuration")
  pf("  -h, --help                 show this help message")
  pf("  -v, --version              print version information and exit")
  pf("      --verbose              be verbose")
  pf("      --debug                be debug mode")
  exit
end

def show_version
  puts "mobileimap #{MobileImap::VERSION}"
  exit
end

def default_config
  config = Hash.new
  config[:imap_user]     = (ENV['USER'] or "unknown")
  config[:imap_auth]     = "CRAM-MD5"
  config[:imap_host]     = "localhost"
  config[:imap_port]     = 143
  config[:imap_password] = nil
  config[:imap_ssl]      = false
  config[:http_host]     = Socket.gethostname
  config[:http_port]     = 8143
  config[:smtp_host]     = "localhost"
  config[:smtp_port]     = 25
  config[:subscriber_id] = nil
  config[:jphone_uid]    = nil
  config[:url_path]      = nil
  config[:daemon_p]      = nil
  config[:verbose_p]     = false
  config[:from]          = config[:imap_user] + "@" + Socket.gethostname
  config[:signature_file_name] = nil

  config[:folder_include] = Regexp.new("")
  config[:folder_exclude] = Regexp.new("^$") #"
  config[:default_folder] = "INBOX"
  config[:default_folder_prefix] = ""
  config[:default_client_width] = 20
  config[:subscribed_only] = false
  config[:cache_control] = false
  config[:fcc_folder] = nil

  dir =  (ENV['HOME'] or "/tmp")
  config[:log_file_name] = File.join(dir, ".mobileimap.log")
  config[:pid_file_name] = File.join(dir, ".mobileimap.pid")

  config[:support_ssl_p] = false
  config[:ssl_key_file_name] = nil
  config[:ssl_cert_file_name] = nil

  config[:allow_hosts] = Regexp.new("")

  return config
end

def set_config (config, key, value)
  if value
    config[key] = if block_given? then yield(value) else value end
  end
end

def parse_options
  options = Hash.new
  parser = GetoptLong.new
  parser.set_options(['--help',          '-h', GetoptLong::NO_ARGUMENT],
                     ['--version',       '-v', GetoptLong::NO_ARGUMENT],
                     ['--verbose',             GetoptLong::NO_ARGUMENT],
                     ['--daemon',        '-d', GetoptLong::NO_ARGUMENT],
                     ['--stop',          '-k', GetoptLong::OPTIONAL_ARGUMENT],
                     ['--list',          '-l', GetoptLong::NO_ARGUMENT],
                     ['--imap-auth',     '-a', GetoptLong::REQUIRED_ARGUMENT],
                     ['--imap-user',     '-u', GetoptLong::REQUIRED_ARGUMENT],
                     ['--imap-host',     '-S', GetoptLong::REQUIRED_ARGUMENT],
                     ['--imap-port',     '-P', GetoptLong::REQUIRED_ARGUMENT],
                     ['--imap-ssl',            GetoptLong::NO_ARGUMENT],
                     ['--from',          '-f', GetoptLong::REQUIRED_ARGUMENT],
                     ['--http-host',     '-s', GetoptLong::REQUIRED_ARGUMENT],
                     ['--http-port',     '-p', GetoptLong::REQUIRED_ARGUMENT],
                     ['--ssl',                 GetoptLong::NO_ARGUMENT],
                     ['--ssl-key',             GetoptLong::REQUIRED_ARGUMENT],
                     ['--ssl-cert',            GetoptLong::REQUIRED_ARGUMENT],
                     ['--smtp-host',           GetoptLong::REQUIRED_ARGUMENT],
                     ['--smtp-port',           GetoptLong::REQUIRED_ARGUMENT],
                     ['--url-path' ,     '-x', GetoptLong::REQUIRED_ARGUMENT],
                     ['--subscribed-only',     GetoptLong::NO_ARGUMENT],
                     ['--folder',	       GetoptLong::REQUIRED_ARGUMENT],
                     ['--folder-include',      GetoptLong::REQUIRED_ARGUMENT],
                     ['--folder-exclude',      GetoptLong::REQUIRED_ARGUMENT],
                     ['--fcc-folder',          GetoptLong::REQUIRED_ARGUMENT],
                     ['--folder-prefix',       GetoptLong::REQUIRED_ARGUMENT],
                     ['--client-width',  '-w', GetoptLong::REQUIRED_ARGUMENT],
                     ['--subscriber-id', '-i', GetoptLong::REQUIRED_ARGUMENT],
                     ['--jphone-uid',    '-j', GetoptLong::REQUIRED_ARGUMENT],
                     ['--mobileimaprc',        GetoptLong::REQUIRED_ARGUMENT],
                     ['--allow-hosts',         GetoptLong::REQUIRED_ARGUMENT],
                     ['--dump-config',         GetoptLong::NO_ARGUMENT],
                     ['--signature',           GetoptLong::REQUIRED_ARGUMENT],
                     ['--debug',               GetoptLong::NO_ARGUMENT])
  parser.each_option {|name, arg|
    options[name.sub(/^--/, "")] = arg
  }

  show_usage if options['help'] or ARGV.length != 0
  show_version if options['version']
  Net::IMAP.debug = true if options['debug']

  config = default_config
  if options['mobileimaprc']
    read_config(config, options['mobileimaprc'])
  elsif ENV['HOME'] and File.exist?(File.join(ENV['HOME'], ".mobileimaprc"))
    read_config(config, File.join(ENV['HOME'], ".mobileimaprc"))
  end

  set_config(config, :imap_user, options['imap-user'])
  set_config(config, :imap_auth, options['imap-auth'])
  set_config(config, :imap_host, options['imap-host'])
  set_config(config, :http_host, options['http-host'])
  set_config(config, :smtp_host, options['smtp-host'])
  set_config(config, :subscriber_id, options['subscriber-id'])
  set_config(config, :jphone_uid, options['jphone-uid'])
  set_config(config, :url_path, options['url-path'])
  set_config(config, :daemon_p, options['daemon']) {|x| 
    if x then true else false end
  }
  set_config(config, :verbose_p, options['verbose'])  {|x| 
    if x then true else false end
  }

  set_config(config, :imap_ssl, options['imap-ssl'])  {|x| 
    if x then true else false end
  }
  set_config(config, :from, options['from'])
  set_config(config, :smtp_port, options['smtp-port']) {|x| x.to_i }
  set_config(config, :imap_port, options['imap-port']) {|x| x.to_i }
  set_config(config, :http_port, options['http-port']) {|x| x.to_i }

  set_config(config, :folder_include, options['folder-include']) {|x| 
    Regexp.new(x) 
  }
  set_config(config, :folder_exclude, options['folder-exclude']) {|x| 
    Regexp.new(x) 
  }
  set_config(config, :default_folder, options['folder'])
  set_config(config, :default_folder_prefix, options['folder-prefix'])
  set_config(config, :default_client_width, options['client-width']) {|x|
    x.to_i 
  }
  set_config(config, :subscribed_only, options['subscribed-only']) {|x| 
    if x then true else false end
  }
  set_config(config, :fcc_folder, options['fcc-folder'])

  if options['ssl'] 
    require 'openssl'
    config[:support_ssl_p] = true
  end
  set_config(config, :ssl_key_file_name,  options['ssl-key'])
  set_config(config, :ssl_cert_file_name, options['ssl-cert'])

  set_config(config, :allow_hosts, options['allow-hosts']) {|x| 
    Regexp.new(x) 
  }

  if options['stop']
    if options['stop'] and !options['stop'].empty?
      urls = options['stop'].split.collect{|url| URI.parse(url) }
      stop_servers(config, urls)
    else
      stop_servers(config)
    end
  end
  list_servers(config) if options['list']
  dump_config(config) if options['dump-config']

  set_config(config, :signature_file_name, options['signature'])

  return config
end

def dump_config (config)
  len = config.map {|key, value| key.inspect.length}.max
  puts "{"
  config.sort {|a, b| a.first.to_s <=> b.first.to_s }.each {|key, value|
    printf("  %-#{len}s => %s,\n", key.inspect, value.inspect)
  }
  puts "}"
  exit(0)
end

def read_config (config, file_name)
  new_config = eval(File.open(file_name).read)
  if new_config
    new_config.each {|key, value|
      config[key] = value
    }
  end
end

def ask_password (host, port, auth, user)
  STDERR.sync = true
  STDERR.printf("%s@%s:%d[%s]: IMAP Password: ", user, host, port, auth)
  begin
    system("stty -echo") if STDIN.tty?
    password = STDIN.gets.chomp
    system("stty echo") if STDIN.tty?
    STDERR.puts
  rescue Exception
    system("stty echo") if STDIN.tty?
    STDERR.puts
    exit(1)
  end
  return password
end

class RequestError < Exception; end

def check_id (config, header, config_key, header_field, name)
  if config[config_key] and config[config_key]  != header[header_field]
    if header[header_field]
      raise RequestError.new(name + "が間違っています: " + header[header_field])
    else
      raise RequestError.new(name + "が空です")
    end
  end
end

def check_request (config, header, url)
  check_id(config, header, :subscriber_id, 'x-up-subno', "サブスクライバID")
  check_id(config, header, :jphone_uid, 'x-jphone-uid', "JPHONEユーザID")

  if config[:url_path] and 
      "/" + config[:url_path] != url.path and
      "/" + config[:url_path] + "/" != url.path and
      ! %r!^/#{Regexp.escape(config[:url_path])}/!.match(url.path) # path_info
    raise RequestError.new("URLのパスが間違っています")
  end

  if config[:http_host] != header['host'].sub(/:\d+$/, "")
    raise RequestError.new("ホスト名が間違っています")
  end
end

def be_daemon (pid_file_name, service_url)
  exit!(0) if fork
  Process::setsid
  exit!(0) if fork
  Dir::chdir("/")
  File::umask(022)
  STDIN.reopen("/dev/null",  "r")
  STDOUT.reopen("/dev/null", "w")
  STDERR.reopen("/dev/null", "w")
  write_pid_file(pid_file_name, service_url)
end

def read_pid_file (pid_file_name)
  begin
    File.open(pid_file_name).map {|line|
      m = /^(\d+)\s*(.+)?$/.match(line)
      pid = m[1].to_i
      url = if m[2] then URI.parse(m[2]) else URI.parse('') end
      [pid, url]
    }
  rescue
    []
  end
end

def write_pid_file (pid_file_name, service_url)
  pids = read_pid_file(pid_file_name).find_all {|pid, url|
    Process.exist?(pid)
  }
  pids.push([Process.pid, service_url])
  update_pid_file(pid_file_name, pids)
end

def update_pid_file (pid_file_name, pids)
  File.open(pid_file_name, "w") {|f| 
    pids.each {|pid, url| f.puts "#{pid} #{url}" }
  }
end

def list_servers (config)
  begin
    pids = read_pid_file(config[:pid_file_name])
    pids.each {|pid, url| puts "#{pid} #{url}" }
  rescue
  end

  exit(0)
end

def stop_servers (config, urls = nil)
  nprocesses = 0
  begin
    pids = read_pid_file(config[:pid_file_name])
    nprocesses = pids.size
    if urls
      kill_pids = pids.find_all {|pid, url| urls.include?(url) }
    else
      kill_pids = pids.dup
    end
    kill_pids.each {|pid, url|
      begin 
        Process.kill("TERM", pid) 
        pids.delete([pid, url])
      rescue Errno::ESRCH # no such process
        pids.delete([pid, url])
      rescue => e
      end
    }
    if pids.empty?
      File.unlink(config[:pid_file_name])
    else
      update_pid_file(config[:pid_file_name], pids)
    end
  rescue
  end
  if nprocesses == pids.size
    puts "no processes are killed" 
    exit(1)
  else
    exit(0)
  end
end

def header_contains? (header, key, value)
  return false unless header[key]
  values = header[key].split(",")
  if values.find {|v| v.strip == value}
    true
  else
    false
  end
end

def gzip_acceptable? (header)
  header_contains?(header, "accept-encoding", "gzip")
end

def x_gzip_acceptable? (header)
  header_contains?(header, "accept-encoding", "x-gzip")
end

def start_server (config, base_url)
  log_file = if config[:daemon_p]
               File.new(config[:log_file_name], "a")
             else
               STDERR
             end
  log_file.chmod(0600) if log_file.respond_to?(:chmod)

  logger = Logger.new(log_file, config[:verbose_p])
  server = if config[:support_ssl_p]
             HttpsServer.new(config[:http_host], config[:http_port], logger,
                             config[:allow_hosts],
                             config[:ssl_key_file_name],
                             config[:ssl_cert_file_name])
           else
             HttpServer.new(config[:http_host], config[:http_port], logger, 
                            config[:allow_hosts])
           end
  be_daemon(config[:pid_file_name], base_url) if config[:daemon_p]

  begin
    server.start {|socket, method, url, header, vars|
      writer = HttpWriter.new(socket, logger)
      if server.instance_of?(HttpServer)
        # FIXME: I don't know why but using SSL and
        # GzipWriter causes unfunished contents occasionally.
        writer.enable_gzip if gzip_acceptable?(header)
        writer.enable_x_gzip if x_gzip_acceptable?(header)
      end

      begin
        ntry = 0
        check_request(config, header, url)
        begin
          imapweb = ImapWeb.new(writer, base_url, config)
          imapweb.process(socket, method, url, header, vars)
        rescue Exception => e
          # I don't know why but it happens occasionally with Courier-IMAP.
          if e.message == "closed stream" and ntry < 5
            ntry += 1
            logger.log "retry for closed stream error (#{ntry})"
            sleep 1
            retry
          end
          logger.log "#{e.message}\n#{e.backtrace}"
          writer.print(e.to_html)
        end
      rescue RequestError => e
        logger.log e.message
        writer.print(e.to_html_simple)
      rescue Exception => e
        logger.log "#{e.message}\n#{e.backtrace}"
        writer.print(e.to_html)
      end
    }
  rescue Interrupt
    server.shutdown
  rescue SignalException => e
    case(e.message)
    when "SIGTERM"
      server.shutdown
    when "SIGHUP"
      logger.reopen
    end
  rescue => e
    logger.log "#{e.message}\n#{e.backtrace}"
  end
end

def main
  # To hide the command line arguments from ps command.
  # It works with Linux, but it doesn't work with FreeBSD.
  $0 = "mobileimap" 

  config = parse_options
  begin
    if config[:imap_password].nil?
      config[:imap_password] = ask_password(config[:imap_host],
                                            config[:imap_port],
                                            config[:imap_auth],
                                            config[:imap_user])
    end
    ImapWeb.validate_authentication(config[:imap_host],
                                    config[:imap_port],
                                    config[:imap_user],
                                    config[:imap_auth],
                                    config[:imap_password],
				    config[:imap_ssl])
  rescue => e
    STDERR.puts e.message
    config[:imap_password] = nil
    retry
  end

  base_url = URI.parse(sprintf("%s://%s:%d/%s", 
                               if config[:support_ssl_p]
                                 "https"
                               else
                                 "http"
                               end,
                               config[:http_host],
                               config[:http_port],
                               (config[:url_path] or "")))

  puts base_url.to_s
  start_server(config, base_url)
end

main
